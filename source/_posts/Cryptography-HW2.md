---
title: Cryptography-HW2
date: 2017-09-19 09:35:47
tags: HW
---

# 题目

9月16日参考代码的原本编写要求：
终极破解
编程实现一个工具，功能：
1）支持如下基本运算
    a. + - * / %
    b. & | ~ ^ << >> <<< >>>
    c. ?: ^% ^-1%
    d. C
其中
 ?: 代表选择运算，例如 cond?T:F
^% 代表模幂运算，例如 m^e%N
^-1% 代表求逆运算，例如 a^-1%N
C 代表常量运算，例如 C

C运算是一个零目运算，没有输入运算数，只有输出结果且不变，例如：此运算函数恒定返回3，另一个运算函数恒定返回5

上述解释是运算内含，但在表达成表达式时，可以采用前序表达式 例如 ^% m e N

上述运算是以callback function的形式，以dll作为载体体现的，主搜索函数中不限制：运算的个数、运算的目数、运算的功能

2）输入一组明文和密文对，例如：
<1,4>
<2,5>
<3,6>
<4,7>
…
要求输出能够满足上述明密文对的加密函数，要求输出使用运算函数个数尽可能少的加密函数

---

# 思路

大致上就是暴力搜, 有几个细节问题.

1. 零目二目三目运算符, 在搜的时候, 优先级, 编排该怎么作. 尤其是还含有零目运算符的情况. 压栈能否很好的实现?
2. 能否不暴搜, 回溯? 递归?(但感觉写着不方便)
3. python与dll的联动. 这个好像还有点麻烦

---

首先是dll的问题

https://www.2cto.com/kf/201112/113910.html
http://blog.csdn.net/lihao21/article/details/46622351
http://blog.csdn.net/adeen/article/details/49759033

一个问题: 我的python环境都是默认64bit, 我这破笔记本就不知道为啥VS15里面没法编译64bit的dll. 

使用anaconda新生成一个32bit的python
># 设置32位
set CONDA_FORCE_32BIT=1
conda create -n py27_32 python=2.7
# 切回系统默认
set CONDA_FORCE_32BIT=
#activate
activate py27_32

问题: dll我明明编写的时候加了默认参数num
```
DLLEXPORT int __stdcall mymultiply(a, b, num = 0) {
    if (num)
        return 2;
    return a * b;
}
```
调用的时候不带第三个参数还是无法运行, 很迷

---

运算符分类
零目: const
单目: ~ 
双目: + - * / % & | ^ << >> <<< >>> ^-1%
三目: ?: ^%

>
C++中，整数分有符号数和无符号数两种，对于这两种数做左移、右移运算，稍有区别：
1、如果是无符号数：不管是左移还是右移都是“逻辑移位”
2、如果是有符号数：
1)如果是做左移运算，那么做的是“逻辑移位”，同 1中无符号数的左移。
2)如果是做右移运算，那么做的是“算术移位”。

麻烦, 不写<<< >>>了, << >>直接按c++的定义来吧

运算符分类
零目: const
单目: ~ 
双目: + - * / % & | ^ << >> ^-1%
三目: ?: ^%
一共15个运算符

得到了myDLL1.cpp

---

想了想直接把运算符的目数写死在main.py里面吧, 由主程序去判断目数, 免得麻烦
得到了myDLL.cpp

使用testdll.py测试了一下, 没有问题, 这个dll就放在这里了.

---

前期准备:

排列组合: 
调用 itertools 获取排列组合的全部情况数
```python
>> from itertools import combinations, permutations
>> permutations([1, 2, 3], 2)
<itertools.permutations at 0x7febfd880fc0>
                # 可迭代对象
>> list(permutations([1, 2, 3], 2))
[(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]

>> list(combinations([1, 2, 3], 2))
[(1, 2), (1, 3), (2, 3)]


```

---

接下来编写主函数, 分几个部分

先将15个算符求组合, 得到一个list

再来一个函数 cal(算符序列, 一对明文,密文, 算符个数), 返回0or1判断该算符列能否匹配这对明文密文. 如果为0将其从算符列踢出.
跑完第一对明文密文, 将新的List用在第二对上, 直到这堆明文密文对用完, 或者List用完

具体的cal:
还要考虑合法性, 数字够不够算符用的, 先判断, 不够直接返回0. 计算方法前缀压栈.

---
最后这么设计

cal(OpList, pair)
计算栈函数, 输入一列操作符OpList, 初值init, 期望结果end. 返回flag=1说明错误,flag=1正确

---

很惨痛, 我把深浅拷贝的含义搞反了, 一直就记得list是深拷贝以为直接复制没问题. 调了半天做了一票测试用例才发现. 

---

看有没有时间重写一下一堆if为dict

答-看来没有

---

测试出了一个错误, 
```
permuOpList = list(permutations(AllOpList, numop))
```
permuOpList不应该用排列, 应该直接做笛卡儿积.

