---
title: 算法4
date: 2018/4/3 16:07
tags: 
---

## 01背包
<!-- more -->

### DP

①、确认子问题和状态 
　　01背包问题需要求解的就是，为了体积V的背包中物体总价值最大化，N件物品中第i件应该放入背包中吗？（其中每个物品最多只能放一件） 
　　为此，我们定义一个二维数组，其中每个元素代表一个状态，即前i个物体中若干个放入体积为V背包中最大价值。数组为：f[N][V]，其中fij表示前i件中若干个物品放入体积为j的背包中的最大价值。 
②、初始状态 
　　初始状态为f[0][0−V]和f[0−N][0]都为0，前者表示前0个物品（也就是空物品）无论装入多大的包中总价值都为0，后者表示体积为0的背包啥价值的物品都装不进去。 
③、转移函数

```
if (背包体积j小于物品i的体积)
    f[i][j] = f[i-1][j] //背包装不下第i个物体，目前只能靠前i-1个物体装包
else
    f[i][j] = max(f[i-1][j], f[i-1][j-Vi] + Wi)
```


到这一步，可以确定的是可能获得的最大价值，但是我们并不清楚具体选择哪几样物品能获得最大价值。

另起一个 x[ ] 数组，x[i]=0表示不拿，x[i]=1表示拿。

m[n][c]为最优值，如果m[n][c]=m[n-1][c] ,说明有没有第n件物品都一样，则x[n]=0 ; 否则 x[n]=1。当x[n]=0时，由x[n-1][c]继续构造最优解；当x[n]=1时，则由x[n-1][c-w[i]]继续构造最优解。以此类推，可构造出所有的最优解。

```
void traceback()  
{  
    for(int i=n;i>1;i--)  
    {  
        if(m[i][c]==m[i-1][c])  
            x[i]=0;  
        else  
        {  
            x[i]=1;  
            c-=w[i];  
        }  
    }  
    x[1]=(m[1][c]>0)?1:0;  
}  
```



## 递归次数

下列程序执行后,输出的结果为()
```c++
#include<stdio.h>
int cnt=0;
int fib(int n)
{
    cnt++;
    if(n==0)
       return 1;
    else if(n==1)
       return 2;
    else
       return fib(n-1)+fib(n-2);
}
void main()
{
   fib(8);
   printf("%d",cnt);
}
```


f(8)------------- 1
f(7)-------------1
f(6)-------1+1=2
f(5)------2+1 = 3
f(4)-------------5
f(3)-------------8
f(2)-------------13
f(1)-------------21
f(0)-------------13
1+1+2+3+5+8+13+21+13=67

## 分箱问题

问题
假设12个销售价格记录组已经排序如下：5, 10, 11, 13, 15,35, 50, 55, 72, 92, 204, 215 使用如下每种方法将它们划分成四个箱。等频（等深）划分时，15在第几个箱子内？等宽划分时在第几个箱？

分箱问题分为有监督分箱和无监督分箱。

无监督分箱
等宽分箱 
     将变量的取值范围分为k个等宽的区间，每个区间当作一个分箱。 
     在本问题中变量的取值范围为5–215，k为4.（215-5）/4=52.5划分点为57.5，110，162.5，4个箱中数据为 
     A箱：5, 10, 11, 13, 15,35, 50, 55 
     B箱：72, 92 
     C箱：空 
     D箱：204, 215
等频（等深）分箱 
     把观测值按照从小到大的顺序排列，根据观测的个数等分为k部分，每部分当作一个分箱，例如，数值最小的1/k比例的观测形成第一个分箱，等等。 
     在本问题中观测个数为12.k=4.每箱里有3个数据。 
     A箱：5, 10, 11, 
B箱：13, 15,35 
C箱： 50, 55，72 
D箱：92 
，204, 215 
k聚类分箱 
     用k均值聚类法将观测值聚为k类，但在聚类过程中需要保证分箱的有序性：第一个分箱中所有观测值都要小于第二个分箱中的观测值，第二个分箱中所有观测值都要小于第三个分箱中的观测值。手算太费时间，笔试中应该不会出现。
有监督分箱
在分箱时考虑因变量的取值，使得分箱后达到最小（minimumentropy）或最小描述长度（minimumdescriptionlength）。

（1）假设因变量为分类变量，可取值1，…，J。令pl（j）表示第l个分箱内因变量取值为j的观测的比例，l=1，…，k，j=1，…，J；那么第l个分箱的熵值为Jj=1［-pl（j）×log（pl（j））］。如果第l个分箱内因变量各类别的比例相等，即pl（1）=…=pl（J）=1/J，那么第l个分箱的熵值达到最大值；如果第l个分箱内因变量只有一种取值，即某个pl（j）等于1而其他类别的比例等于0，那么第l个分箱的熵值达到最小值。

（2）令rl表示第l个分箱的观测数占所有观测数的比例；那么总熵值为kl= 1rl×Jj=1［-pl（j）×log（pl（j ））］。需要使总熵值达到最小，也就是使分箱能够最大限度地区分因变量的各类别。


## gets getchar scanf getline

gets是得到一整行的字符串;
getchar是得到一个字符；
scanf("%s")是得到一个连续的字符串，遇到空格、回车会自动终止
getline 一行扔掉换行符


## 卡兰特数列

https://www.zhihu.com/question/25072237/answer/30111179

## 坐标点的表示


P为给定的二维平面整数点集。定义 P 中某点x，如果x满足 P 中任意点都不在 x 的右上方区域内（横纵坐标都大于x），则称其为“最大的”。求出所有“最大的”点的集合。（所有点的横坐标和纵坐标都不重复, 坐标轴范围在[0, 1e9) 内）

如下图：实心点为满足条件的点的集合。请实现代码找到集合 P 中的所有 ”最大“ 点的集合并输出。

输入描述:
第一行输入点集的个数 N， 接下来 N 行，每行两个数字代表点的 X 轴和 Y 轴。
对于 50%的数据,  1 <= N <= 10000;
对于 100%的数据, 1 <= N <= 500000;


输出描述:
输出“最大的” 点集合， 按照 X 轴从小到大的方式输出，每行两个数字分别代表点的 X 轴和 Y轴。
示例1
输入
5
1 2
5 3
4 6
7 5
9 0
输出
4 6
7 5
9 0



一个点右上方没有点，也就是一个点右边的点全都在它的下边。
所以我们将点按照横坐标从左到右排序，从右开始扫，找出右边点最大纵坐标。
那么一个点的纵坐标比右边的点纵坐标最大值还大，就说明这个点右边的点全在它的下面。
这样选择点就可以选出所有符合条件的点了。
```c++
#include <bits/stdc++.h>
using namespace std;
#define pb push_back
#define pr make_pair
#define fi first
#define se second
const int MAX_N = 5e5 + 5;
typedef pair<int, int> pii;
vector<pii> p;
pii ans[MAX_N];
int main() {
    int n, x, y, num, limit;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%d%d", &x, &y);
        p.pb(pr(x, y));
    }
    sort(p.begin(), p.end());
    num = 0, limit = -1;
    for (int i = n - 1; i >= 0; i--) {
        if (p[i].se > limit) {
            ans[num] = p[i];
            num++;
            limit = p[i].se;
        }
    }
    for (int i = num - 1; i >= 0; i--) {
        printf("%d %d\n", ans[i].fi, ans[i].se);
    }
    return 0;
}
```

## bit-map

https://blog.csdn.net/BillCYJ/article/details/78948977

游戏里面有很多各式各样的任务，其中有一种任务玩家只能做一次，这类任务一共有1024个，任务ID范围[1,1024]。请用32个unsigned int类型来记录着1024个任务是否已经完成。初始状态都是未完成。 输入两个参数，都是任务ID，需要设置第一个ID的任务为已经完成；并检查第二个ID的任务是否已经完成。 输出一个参数，如果第二个ID的任务已经完成输出1，如果未完成输出0。如果第一或第二个ID不在[1,1024]范围，则输出-1。 
输入描述:
输入包括一行,两个整数表示人物ID.


输出描述:
输出是否完成

输入例子1:
1024 1024

输出例子1:
1

```c++

//解释：1024=32*32,因此可用32个整数表示1024位(因为每个整数32位)
//因为任务ID范围是1~1024,所以减1转化为0~1023
//然后任务ID除以32，商为存到哪个整数，余数为该整数对应位（置1即可）
//注：除以32相当于直接右移5位，对32取余相当于"与31"（这个技巧只对2的次方数有效）．
//拓展：大数据处理，可自行查找1-bitmap和2-bitmap．
#include <iostream>
using namespace std;
    
unsigned int arr[32];
    
int main()
{
    int id1, id2;
    while(cin>>id1>>id2)
    {
        if(!(id2>=1 && id2<=1024))
        {
            cout<<-1<<endl;
            continue;
        }
        arr[(id1-1)>>5] |= (1<<(id1&31));
        cout<<( (arr[(id2-1)>>5] & (1<<(id2&31))) != 0)<<endl;
    }
    return 0;
}
```

## 筛法素数

```c++

    vector<int> v(1000,1);
    for(int i=2;i<1000;++i){
        for(int j=2;i*j<1000;++j){
            if(v[i]){
                v[i*j]=0;
            }
        }
    }
```

## 字符串转数字

atoi(temp.c_str())
字符串转数字(后面要是一个c字符串指针, 所以c_str)

string temp = to_string(num);

输入一个数组 (size n1 n2 n3...)

int size;
cin >> size;
vector<int> nums(size);
for(size_t i = 0; i < size; ++i)
    cin >> nums[i];



## 最长公共连续子串

这题其实是动态规划的变形经典题型，应用动态规划的思想，创建一个二维数组dp[n][n]，其中dp[i][j]，表示取到s1[i]和取到s2[j]时的最大连续子串长度。如果s1[i]等于s2[j]，则dp[i-1][j-1]等于取到s1[i-1]和取到s2[j-1]时的最大连续子串长度加1，即dp[i][j]=dp[i-1][j-1]+1。

## LCS 最大公共子序列

https://blog.csdn.net/so_geili/article/details/53737001


## KMP

https://blog.csdn.net/starstar1992/article/details/54913261

https://blog.csdn.net/v_july_v/article/details/7041827